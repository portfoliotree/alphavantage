package main

import (
	"bytes"
	"cmp"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"net/url"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"

	"github.com/portfoliotree/alphavantage/specification"
)

const generateComment = "// Code generated by av-generate; DO NOT EDIT."

func main() {
	idsBuf, err := os.ReadFile(filepath.FromSlash("specification/identifiers.json"))
	if err != nil {
		panic(err)
	}
	var goIdentifiers map[string][]string
	if err := json.Unmarshal(idsBuf, &goIdentifiers); err != nil {
		panic(err)
	}

	qpBuf, err := os.ReadFile(filepath.FromSlash("specification/query_parameters.json"))
	if err != nil {
		panic(err)
	}
	var queryParams []specification.QueryParameter
	if err := json.Unmarshal(qpBuf, &queryParams); err != nil {
		panic(err)
	}

	filePaths, err := filepath.Glob(filepath.FromSlash("specification/functions/*.json"))
	if err != nil {
		panic(err)
	}

	functionFiles := make(map[string][]specification.Function)

	for _, filePath := range filePaths {
		buf, err := os.ReadFile(filePath)
		if err != nil {
			panic(err)
		}
		var functions []specification.Function
		err = json.Unmarshal(buf, &functions)
		if err != nil {
			panic(err)
		}
		functionFiles[filePath] = functions
	}

	const pkgName = "alphavantage"

	for filePath, functions := range functionFiles {
		baseFileName := strings.TrimSuffix(filepath.Base(filePath), ".json")

		slices.SortFunc(functions, func(a, b specification.Function) int {
			return cmp.Compare(goIdentifiers[a.Name][0], goIdentifiers[b.Name][0])
		})

		outFileName := filepath.Join(baseFileName + ".go")

		if err := generateFile(pkgName, outFileName, baseFileName, functions, goIdentifiers, queryParams); err != nil {
			panic(err)
		}
	}

	// Generate CLI functions.go
	if err := generateCLIFile(functionFiles, goIdentifiers, queryParams); err != nil {
		panic(err)
	}

	// Generate CLI test data
	if err := generateCLITestData(functionFiles); err != nil {
		panic(err)
	}
}

func generateFile(pkgName, outFileName, baseFileName string, functions []specification.Function, goIdentifiers map[string][]string, queryParams []specification.QueryParameter) error {
	file := ast.File{
		Name: ast.NewIdent(pkgName),
	}
	importsDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: []ast.Spec{},
	}
	file.Decls = append(file.Decls, importsDecl)

	imports := []string{
		"net/url",
	}

	for _, fn := range functions {
		goIdent := goIdentifiers[fn.Name][0]
		rowTypeIdent := goIdent + "Row"
		queryTypeIdent := goIdent + "Query"

		file.Decls = append(file.Decls, &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: ast.NewIdent(queryTypeIdent),
					Type: newSel("url", "Values"),
				},
			},
		})
		queryFuncDecls, im, err := queryInitializerFunc(goIdent, queryTypeIdent, fn, goIdentifiers, queryParams)
		if err != nil {
			return err
		}

		imports = append(imports, im...)
		slices.Sort(imports)
		imports = slices.Compact(imports)

		for _, fnDecl := range queryFuncDecls {
			file.Decls = append(file.Decls, fnDecl)
		}

		getIdent := "Get" + goIdent
		file.Decls = append(file.Decls, &ast.FuncDecl{
			Name: ast.NewIdent(getIdent),
			Recv: &ast.FieldList{
				List: []*ast.Field{
					{Names: []*ast.Ident{ast.NewIdent("client")}, Type: &ast.StarExpr{X: ast.NewIdent("Client")}},
				},
			},
			Type: &ast.FuncType{
				Params: &ast.FieldList{
					List: []*ast.Field{
						{Names: []*ast.Ident{ast.NewIdent("ctx")}, Type: newSel("context", "Context")},
						{Names: []*ast.Ident{ast.NewIdent("q")}, Type: ast.NewIdent(queryTypeIdent)},
					},
				},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{Type: &ast.StarExpr{
							X: newSel("http", "Response"),
						}},
						{Type: ast.NewIdent("error")},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("req"),
							ast.NewIdent("err"),
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.CallExpr{
								Fun: newSel("client", "newRequest"),
								Args: []ast.Expr{
									ast.NewIdent("ctx"),
									&ast.CallExpr{
										Fun:  newSel("url", "Values"),
										Args: []ast.Expr{ast.NewIdent("q")},
									},
								},
							},
						},
					},
					&ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X:  ast.NewIdent("err"),
							Op: token.NEQ,
							Y:  ast.NewIdent("nil"),
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.ReturnStmt{
									Results: []ast.Expr{
										ast.NewIdent("nil"),
										ast.NewIdent("err"),
									},
								},
							},
						},
					},
					&ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("res"),
							ast.NewIdent("err"),
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.CallExpr{
								Fun: newSel("client", "Do"),
								Args: []ast.Expr{
									ast.NewIdent("req"),
								},
							},
						},
					},
					&ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X:  ast.NewIdent("err"),
							Op: token.NEQ,
							Y:  ast.NewIdent("nil"),
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.ReturnStmt{
									Results: []ast.Expr{
										ast.NewIdent("nil"),
										ast.NewIdent("err"),
									},
								},
							},
						},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{
							ast.NewIdent("res"),
							ast.NewIdent("nil"),
						},
					},
				},
			},
		})

		imports = append(imports, "context", "net/http")
		slices.Sort(imports)
		imports = slices.Compact(imports)

		if !fn.HasDatatypeParameter() ||
			slices.Contains([]string{"REALTIME_BULK_QUOTES", "REALTIME_OPTIONS", "BOP"}, fn.Name) {
			continue
		}

		getFuncRows := "Get" + goIdent + "CSVRows"
		file.Decls = append(file.Decls, &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: ast.NewIdent(rowTypeIdent),
					Type: &ast.StructType{
						Fields: csvFields(baseFileName, fn, goIdentifiers),
					},
				},
			},
		}, &ast.FuncDecl{
			Name: ast.NewIdent(getFuncRows),
			Recv: &ast.FieldList{
				List: []*ast.Field{
					{Names: []*ast.Ident{ast.NewIdent("client")}, Type: &ast.StarExpr{X: ast.NewIdent("Client")}},
				},
			},
			Type: &ast.FuncType{
				Params: &ast.FieldList{
					List: []*ast.Field{
						{Names: []*ast.Ident{ast.NewIdent("ctx")}, Type: newSel("context", "Context")},
						{Names: []*ast.Ident{ast.NewIdent("q")}, Type: ast.NewIdent(queryTypeIdent)},
					},
				},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{Type: &ast.ArrayType{Elt: ast.NewIdent(rowTypeIdent)}},
						{Type: ast.NewIdent("error")},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun:  newSel("q", "DataTypeCSV"),
							Args: []ast.Expr{},
						},
					},
					&ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("res"),
							ast.NewIdent("err"),
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.CallExpr{
								Fun: newSel("client", "Get"+goIdent),
								Args: []ast.Expr{
									ast.NewIdent("ctx"),
									ast.NewIdent("q"),
								},
							},
						},
					},
					&ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X:  ast.NewIdent("err"),
							Op: token.NEQ,
							Y:  ast.NewIdent("nil"),
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.ReturnStmt{
									Results: []ast.Expr{
										ast.NewIdent("nil"),
										ast.NewIdent("err"),
									},
								},
							},
						},
					},
					&ast.DeferStmt{
						Call: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   newSel("res", "Body"),
								Sel: ast.NewIdent("Close"),
							},
							Args: []ast.Expr{},
						},
					},
					&ast.DeclStmt{
						Decl: &ast.GenDecl{
							Tok: token.VAR,
							Specs: []ast.Spec{
								&ast.ValueSpec{
									Names: []*ast.Ident{ast.NewIdent("rows")},
									Type: &ast.ArrayType{
										Elt: ast.NewIdent(rowTypeIdent),
									},
								},
							},
						},
					},
					&ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("err"),
						},
						Tok: token.ASSIGN,
						Rhs: []ast.Expr{
							&ast.CallExpr{
								Fun: ast.NewIdent("ParseCSV"),
								Args: []ast.Expr{
									newSel("res", "Body"),
									&ast.UnaryExpr{
										Op: token.AND,
										X:  ast.NewIdent("rows"),
									},
									ast.NewIdent("nil"),
								},
							},
						},
					},
					&ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X:  ast.NewIdent("err"),
							Op: token.NEQ,
							Y:  ast.NewIdent("nil"),
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.ReturnStmt{
									Results: []ast.Expr{
										ast.NewIdent("nil"),
										ast.NewIdent("err"),
									},
								},
							},
						},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{
							ast.NewIdent("rows"),
							ast.NewIdent("nil"),
						},
					},
				},
			},
		})
	}

	if len(file.Decls) <= 1 {
		return nil
	}

	slices.Sort(imports)
	imports = slices.Compact(imports)
	for _, im := range imports {
		importsDecl.Specs = append(importsDecl.Specs, &ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(im)}})
	}

	var buf bytes.Buffer
	buf.WriteString(generateComment + "\n\n")
	if err := format.Node(&buf, token.NewFileSet(), &file); err != nil {
		return err
	}

	return os.WriteFile(outFileName, buf.Bytes(), 0644)
}

func queryInitializerFunc(goIdent, queryTypeIdent string, fn specification.Function, goIdentifiers map[string][]string, queryParams []specification.QueryParameter) ([]*ast.FuncDecl, []string, error) {
	requiredFields := &ast.Field{
		Type: ast.NewIdent("string"),
	}
	if slices.Contains(fn.Required, "apikey") {
		requiredFields.Names = append(requiredFields.Names, ast.NewIdent(goIdentifiers["apikey"][1]))
	}

	elements := []ast.Expr{
		&ast.KeyValueExpr{
			Key: &ast.BasicLit{Kind: token.STRING, Value: strconv.Quote("function")},
			Value: &ast.CompositeLit{
				Type: &ast.ArrayType{Elt: ast.NewIdent("string")},
				Elts: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(fn.Name)}},
			},
		},
	}

	for _, req := range fn.Required {
		switch req {
		case "function":
		default:
			requiredFields.Names = append(requiredFields.Names, ast.NewIdent(goIdentifiers[req][1]))
			fallthrough
		case "apikey":
			elements = append(elements, &ast.KeyValueExpr{
				Key: &ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(req)},
				Value: &ast.CompositeLit{
					Type: &ast.ArrayType{Elt: ast.NewIdent("string")},
					Elts: []ast.Expr{ast.NewIdent(goIdentifiers[req][1])},
				},
			})
		}
	}

	decls := []*ast.FuncDecl{
		{
			Name: ast.NewIdent("Query" + goIdent),
			Type: &ast.FuncType{
				Params:  &ast.FieldList{List: []*ast.Field{requiredFields}},
				Results: &ast.FieldList{List: []*ast.Field{newField(ast.NewIdent(queryTypeIdent))}},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.CompositeLit{
								Type: ast.NewIdent(queryTypeIdent),
								Elts: elements,
							},
						},
					},
				},
			},
		},
	}

	var imports []string

	for _, opt := range fn.Optional {
		var methodName string
		switch opt {
		case "OHLC":
			methodName = "OHLC"
		default:
			ids, ok := goIdentifiers[opt]
			if ok {
				methodName = ids[0]
			} else {
				panic("unknown option: " + opt)
			}
		}

		if idx := slices.IndexFunc(queryParams, func(p specification.QueryParameter) bool {
			return p.Name == opt
		}); idx >= 0 {
			qp := queryParams[idx]
			switch qp.Type {
			case "enum":
				for _, val := range qp.Values {
					s, err := val.Name()
					if err != nil {
						return nil, nil, fmt.Errorf("failed to get name for query param key %s: %w", opt, err)
					}
					valueIdent, ok := goIdentifiers[s]
					if ok {
						decls = append(decls, queryUpdateMethod(queryTypeIdent, methodName+valueIdent[0], opt,
							[]*ast.Field{},
							&ast.CompositeLit{
								Type: &ast.ArrayType{Elt: ast.NewIdent("string")},
								Elts: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(s)}},
							},
						))
					}
				}
			case "bool":
				decls = append(decls, queryUpdateMethod(queryTypeIdent, methodName, opt,
					[]*ast.Field{newField(ast.NewIdent("bool"), "value")},
					&ast.CompositeLit{
						Type: &ast.ArrayType{Elt: ast.NewIdent("string")},
						Elts: []ast.Expr{&ast.CallExpr{
							Fun:  &ast.SelectorExpr{X: ast.NewIdent("strconv"), Sel: ast.NewIdent("FormatBool")},
							Args: []ast.Expr{ast.NewIdent("value")},
						}},
					},
				))
				imports = append(imports, "strconv")
				continue
			case "time":
				if qp.Format != "" {
					decls = append(decls, queryUpdateMethod(queryTypeIdent, methodName, opt,
						[]*ast.Field{newField(newSel("time", "Time"), "value")},
						&ast.CompositeLit{
							Type: &ast.ArrayType{Elt: ast.NewIdent("string")},
							Elts: []ast.Expr{&ast.CallExpr{
								Fun:  &ast.SelectorExpr{X: ast.NewIdent("value"), Sel: ast.NewIdent("Format")},
								Args: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(qp.Format)}},
							}},
						},
					))
					imports = append(imports, "time")
				}
				continue
			}
		}
		decls = append(decls, queryUpdateMethod(queryTypeIdent, methodName, opt,
			[]*ast.Field{newField(ast.NewIdent("string"), "value")},
			&ast.CompositeLit{
				Type: &ast.ArrayType{Elt: ast.NewIdent("string")},
				Elts: []ast.Expr{ast.NewIdent("value")},
			},
		))
	}

	slices.Sort(imports)
	imports = slices.Compact(imports)

	return decls, imports, nil
}

func queryUpdateMethod(queryTypeIdent, methodName, keyName string, params []*ast.Field, expr ast.Expr) *ast.FuncDecl {
	return &ast.FuncDecl{
		Name: ast.NewIdent(methodName),
		Recv: &ast.FieldList{List: []*ast.Field{newField(ast.NewIdent(queryTypeIdent), "query")}},
		Type: &ast.FuncType{
			Params:  &ast.FieldList{List: params},
			Results: &ast.FieldList{List: []*ast.Field{{Type: ast.NewIdent(queryTypeIdent)}}},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.IndexExpr{
							X:     ast.NewIdent("query"),
							Index: &ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(keyName)},
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{expr},
				},
				&ast.ReturnStmt{Results: []ast.Expr{ast.NewIdent("query")}},
			},
		},
	}
}

func csvFields(baseFileName string, fn specification.Function, goIdentifiers map[string][]string) *ast.FieldList {
	if strings.HasPrefix(baseFileName, "technical_") && len(fn.CSVColumns) == 2 {
		return &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent(goIdentifiers[fn.CSVColumns[0].Name][0])},
					Type:  ast.NewIdent("string"),
					Tag: &ast.BasicLit{
						Kind:  token.STRING,
						Value: "`" + fmt.Sprintf(`column-name:%q`, fn.CSVColumns[0].Name) + "`",
					},
				},
				{
					Names: []*ast.Ident{ast.NewIdent("Value")},
					Type:  ast.NewIdent("string"),
					Tag: &ast.BasicLit{
						Kind:  token.STRING,
						Value: "`" + fmt.Sprintf(`column-name:%q`, fn.CSVColumns[1].Name) + "`",
					},
				},
			},
		}
	}

	fields := ast.FieldList{}
	for _, col := range fn.CSVColumns {
		fieldName := col.Name
		if fieldName == fn.Name {
			fieldName = "Value"
		} else {
			ns, ok := goIdentifiers[fieldName]
			if ok {
				fieldName = ns[0]
			}
		}
		var (
			fieldType ast.Expr
			tag       string
		)
		switch col.Type {
		case "string", "float64", "int":
			fieldType = ast.Expr(ast.NewIdent(col.Type))
			tag = "`" + fmt.Sprintf(`column-name:%q`, col.Name) + "`"
		case "time":
			fieldType = newSel("time", "Time")
			if col.Format != "" {
				tag = "`" + fmt.Sprintf(`column-name:%q time-layout:%q`, col.Name, col.Format) + "`"
			}

		default:
			panic(fmt.Sprintf("unsupported column type %q for function %q", col.Type, fn.Name))
		}

		fields.List = append(fields.List, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(fieldName)},
			Type:  fieldType,
			Tag: &ast.BasicLit{
				Kind:  token.STRING,
				Value: tag,
			},
		})
	}
	return &fields
}

func generateCLIFile(functionFiles map[string][]specification.Function, goIdentifiers map[string][]string, queryParams []specification.QueryParameter) error {
	var allFunctions []specification.Function
	for _, functions := range functionFiles {
		allFunctions = append(allFunctions, functions...)
	}

	slices.SortFunc(allFunctions, func(a, b specification.Function) int { return cmp.Compare(a.Name, b.Name) })

	file := &ast.File{Name: ast.NewIdent("main")}

	importsMap := newSet("context", "fmt", "io")

	var caseClauses []ast.Stmt
	for _, fn := range allFunctions {
		caseClauses = append(caseClauses,
			&ast.CaseClause{
				List: []ast.Expr{
					&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(fn.Name)},
					&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(strings.ToLower(strings.Replace(fn.Name, "_", "-", -1)))},
				},
				Body: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.CallExpr{
								Fun: ast.NewIdent("handle" + goIdentifiers[fn.Name][0]),
								Args: []ast.Expr{
									ast.NewIdent("client"),
									ast.NewIdent("args"),
									ast.NewIdent("output"),
								},
							},
						},
					},
				},
			},
		)
	}

	caseClauses = append(caseClauses, &ast.CaseClause{
		List: nil, // default case
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.CallExpr{
						Fun: newSel("fmt", "Errorf"),
						Args: []ast.Expr{
							&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote("unknown function: %s")},
							ast.NewIdent("functionName"),
						},
					},
				},
			},
		},
	})

	runFunctionDecl := &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Text: "// RunFunction executes the specified AlphaVantage API function with the given arguments."},
			},
		},
		Name: ast.NewIdent("RunFunction"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					newField(&ast.StarExpr{X: newSel("alphavantage", "Client")}, "client"),
					newField(ast.NewIdent("string"), "functionName"),
					newField(&ast.ArrayType{Elt: ast.NewIdent("string")}, "args"),
					newField(newSel("io", "Writer"), "output"),
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{Type: ast.NewIdent("error")}},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.SwitchStmt{
					Tag:  ast.NewIdent("functionName"),
					Body: &ast.BlockStmt{List: caseClauses},
				},
			},
		},
	}

	file.Decls = append(file.Decls, runFunctionDecl)

	for _, fn := range allFunctions {
		funcDecl, fnImports, err := generateHandlerFunction(fn, goIdentifiers, queryParams)
		if err != nil {
			return err
		}
		file.Decls = append(file.Decls, funcDecl)

		for _, imp := range fnImports {
			importsMap[imp] = struct{}{}
		}
	}

	var (
		importSpecs []ast.Spec
		imports     []string
	)
	for imp := range importsMap {
		imports = append(imports, imp)
	}
	slices.Sort(imports)
	imports = append(imports, "github.com/spf13/pflag", "github.com/portfoliotree/alphavantage")

	for _, imp := range imports {
		importSpecs = append(importSpecs, &ast.ImportSpec{
			Path: &ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(imp)},
		})
	}

	if len(importSpecs) > 0 {
		file.Decls = append([]ast.Decl{
			&ast.GenDecl{
				Tok:   token.IMPORT,
				Specs: importSpecs,
			},
		}, file.Decls...)
	}

	var buf bytes.Buffer
	buf.WriteString(generateComment + "\n\n")
	if err := format.Node(&buf, token.NewFileSet(), file); err != nil {
		return fmt.Errorf("failed to format generated CLI code: %w", err)
	}

	return os.WriteFile(filepath.FromSlash("cmd/av/functions.go"), buf.Bytes(), 0644)
}

func generateHandlerFunction(fn specification.Function, goIdentifiers map[string][]string, queryParams []specification.QueryParameter) (*ast.FuncDecl, []string, error) {
	goIdent := goIdentifiers[fn.Name][0]

	var (
		imports []string
		body    []ast.Stmt
	)

	body = append(body, &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("flags")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: newSel("pflag", "NewFlagSet"),
				Args: []ast.Expr{
					&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(fn.Name)},
					newSel("pflag", "ContinueOnError"),
				},
			},
		},
	})

	for _, paramName := range append(fn.Required, fn.Optional...) {
		if paramName == "function" || paramName == "apikey" {
			continue
		}

		varName := goIdentifiers[paramName][1]
		flagName := strings.Replace(paramName, "_", "-", -1)
		flagName = strings.ToLower(flagName)

		paramType := "string"
		var usage string
		for _, qp := range queryParams {
			if qp.Name == paramName {
				paramType = qp.Type
				if qp.Type == "enum" {
					var enumValues []string
					for _, v := range qp.Values {
						val, _ := v.Name()
						if fn.EnumSubset != nil {
							if subset, ok := fn.EnumSubset[paramName]; ok {
								if !slices.Contains(subset, val) {
									continue
								}
							}
						}
						enumValues = append(enumValues, val)
					}
					if len(enumValues) > 0 {
						usage = "options: " + strings.Join(enumValues, ", ")
					}
				}
				break
			}
		}

		if slices.Contains(fn.Required, paramName) {
			usage = "[REQUIRED] " + usage
		}

		var (
			varType      ast.Expr
			flagMethod   string
			defaultValue ast.Expr
		)

		switch paramType {
		case "bool":
			varType = ast.NewIdent("bool")
			flagMethod = "BoolVar"
			defaultValue = ast.NewIdent("false")
		case "int":
			varType = ast.NewIdent("int")
			flagMethod = "IntVar"
			defaultValue = &ast.BasicLit{Kind: token.INT, Value: "0"}
		default:
			varType = ast.NewIdent("string")
			flagMethod = "StringVar"
			defaultValue = &ast.BasicLit{Kind: token.STRING, Value: `""`}
		}

		body = append(body, &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{ast.NewIdent(varName)},
						Type:  varType,
					},
				},
			},
		})

		body = append(body, &ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: newSel("flags", flagMethod),
				Args: []ast.Expr{
					&ast.UnaryExpr{Op: token.AND, X: ast.NewIdent(varName)},
					&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(flagName)},
					defaultValue,
					&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(strings.TrimSpace(usage))},
				},
			},
		})
	}

	body = append(body, &ast.IfStmt{
		Init: &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("err")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun:  newSel("flags", "Parse"),
					Args: []ast.Expr{ast.NewIdent("args")},
				},
			},
		},
		Cond: &ast.BinaryExpr{
			X:  ast.NewIdent("err"),
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{Results: []ast.Expr{ast.NewIdent("err")}},
			},
		},
	})

	for _, paramName := range fn.Required {
		if paramName == "function" || paramName == "apikey" {
			continue
		}

		varName := goIdentifiers[paramName][1]
		flagName := strings.Replace(paramName, "_", "-", -1)
		flagName = strings.ToLower(flagName)

		paramType := "string"
		for _, qp := range queryParams {
			if qp.Name == paramName {
				paramType = qp.Type
				break
			}
		}

		if paramType == "bool" {
			continue
		}

		var cond ast.Expr
		if paramType == "int" {
			cond = &ast.BinaryExpr{
				X:  ast.NewIdent(varName),
				Op: token.EQL,
				Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
			}
		} else {
			cond = &ast.BinaryExpr{
				X:  ast.NewIdent(varName),
				Op: token.EQL,
				Y:  &ast.BasicLit{Kind: token.STRING, Value: `""`},
			}
		}

		body = append(body, &ast.IfStmt{
			Cond: cond,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.CallExpr{
								Fun: newSel("fmt", "Errorf"),
								Args: []ast.Expr{
									&ast.BasicLit{
										Kind:  token.STRING,
										Value: strconv.Quote(fmt.Sprintf("required flag --%s not set", flagName)),
									},
								},
							},
						},
					},
				},
			},
		})
	}

	queryArgs := []ast.Expr{newSel("client", "APIKey")}
	needsStrconv := false

	for _, paramName := range fn.Required {
		if paramName == "function" || paramName == "apikey" {
			continue
		}

		varName := goIdentifiers[paramName][1]

		paramType := "string"
		for _, qp := range queryParams {
			if qp.Name == paramName {
				paramType = qp.Type
				break
			}
		}

		if paramType == "int" {
			needsStrconv = true
			queryArgs = append(queryArgs, &ast.CallExpr{
				Fun:  newSel("strconv", "Itoa"),
				Args: []ast.Expr{ast.NewIdent(varName)},
			})
		} else {
			queryArgs = append(queryArgs, ast.NewIdent(varName))
		}
	}

	body = append(body, &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("query")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun:  newSel("alphavantage", "Query"+goIdent),
				Args: queryArgs,
			},
		},
	})

	for _, paramName := range fn.Optional {
		varName := goIdentifiers[paramName][1]
		methodName := goIdentifiers[paramName][0]

		if paramName == "OHLC" {
			methodName = "OHLC"
		}

		paramType := "string"
		for _, qp := range queryParams {
			if qp.Name == paramName {
				paramType = qp.Type
				break
			}
		}

		var (
			cond       ast.Expr
			methodArg  ast.Expr
			innerStmts []ast.Stmt
		)

		switch paramType {
		case "bool":
			cond = ast.NewIdent(varName)
			methodArg = ast.NewIdent(varName)
			innerStmts = []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("query")},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun:  newSel("query", methodName),
							Args: []ast.Expr{methodArg},
						},
					},
				},
			}
		case "int":
			needsStrconv = true
			cond = &ast.BinaryExpr{
				X:  ast.NewIdent(varName),
				Op: token.NEQ,
				Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
			}
			methodArg = &ast.CallExpr{
				Fun:  newSel("strconv", "Itoa"),
				Args: []ast.Expr{ast.NewIdent(varName)},
			}
			innerStmts = []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("query")},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("query"),
								Sel: ast.NewIdent(methodName),
							},
							Args: []ast.Expr{methodArg},
						},
					},
				},
			}
		case "time":
			imports = append(imports, "time")
			cond = &ast.BinaryExpr{
				X:  ast.NewIdent(varName),
				Op: token.NEQ,
				Y:  &ast.BasicLit{Kind: token.STRING, Value: `""`},
			}
			innerStmts = []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("t"), ast.NewIdent("err")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: newSel("time", "Parse"),
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote("2006-01")},
								ast.NewIdent(varName),
							},
						},
					},
				},
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X:  ast.NewIdent("err"),
						Op: token.NEQ,
						Y:  ast.NewIdent("nil"),
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									&ast.CallExpr{
										Fun: newSel("fmt", "Errorf"),
										Args: []ast.Expr{
											&ast.BasicLit{
												Kind:  token.STRING,
												Value: strconv.Quote(fmt.Sprintf("invalid %s format: %%w", paramName)),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("query")},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun:  newSel("query", methodName),
							Args: []ast.Expr{ast.NewIdent("t")},
						},
					},
				},
			}
		default:
			cond = &ast.BinaryExpr{
				X:  ast.NewIdent(varName),
				Op: token.NEQ,
				Y:  &ast.BasicLit{Kind: token.STRING, Value: `""`},
			}
			methodArg = ast.NewIdent(varName)
			innerStmts = []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("query")},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun:  newSel("query", methodName),
							Args: []ast.Expr{methodArg},
						},
					},
				},
			}
		}

		body = append(body, &ast.IfStmt{
			Cond: cond,
			Body: &ast.BlockStmt{List: innerStmts},
		})
	}

	imports = append(imports, "context")
	body = append(body, &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("ctx")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: newSel("context", "Background"),
			},
		},
	})

	body = append(body, &ast.AssignStmt{
		Lhs: []ast.Expr{ast.NewIdent("res"), ast.NewIdent("err")},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: newSel("client", "Get"+goIdent),
				Args: []ast.Expr{
					ast.NewIdent("ctx"),
					ast.NewIdent("query"),
				},
			},
		},
	})

	body = append(body, &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X:  ast.NewIdent("err"),
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: newSel("fmt", "Errorf"),
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote("API request failed: %w")},
								ast.NewIdent("err"),
							},
						},
					},
				},
			},
		},
	})

	body = append(body, &ast.DeferStmt{
		Call: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   newSel("res", "Body"),
				Sel: ast.NewIdent("Close"),
			},
		},
	})

	imports = append(imports, "io")
	body = append(body, &ast.IfStmt{
		Init: &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("_"), ast.NewIdent("err")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: newSel("io", "Copy"),
					Args: []ast.Expr{
						ast.NewIdent("output"),
						newSel("res", "Body"),
					},
				},
			},
		},
		Cond: &ast.BinaryExpr{
			X:  ast.NewIdent("err"),
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: newSel("fmt", "Errorf"),
							Args: []ast.Expr{
								&ast.BasicLit{Kind: token.STRING, Value: strconv.Quote("failed to write response: %w")},
								ast.NewIdent("err"),
							},
						},
					},
				},
			},
		},
	})

	body = append(body, &ast.ReturnStmt{Results: []ast.Expr{ast.NewIdent("nil")}})

	if needsStrconv {
		imports = append(imports, "strconv")
	}

	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent("handle" + goIdent),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					newField(&ast.StarExpr{X: newSel("alphavantage", "Client")}, "client"),
					newField(&ast.ArrayType{Elt: ast.NewIdent("string")}, "args"),
					newField(newSel("io", "Writer"), "output"),
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: body,
		},
	}

	return funcDecl, imports, nil
}

func generateCLITestData(functionFiles map[string][]specification.Function) error {
	type indexEntry struct {
		ID      string `json:"ID"`
		Path    string `json:"path"`
		Fetched string `json:"fetched"`
		URL     string `json:"url"`
	}

	type testCase struct {
		Name string   `json:"name"`
		Args []string `json:"args"`
	}

	indexPath := filepath.FromSlash("specification/testdata/examples/index.json")
	indexData, err := os.ReadFile(indexPath)
	if err != nil {
		return fmt.Errorf("failed to read index.json: %w", err)
	}

	var index []indexEntry
	if err := json.Unmarshal(indexData, &index); err != nil {
		return fmt.Errorf("failed to parse index.json: %w", err)
	}

	urlToID := make(map[string]string)
	for _, entry := range index {
		parsedURL, err := url.Parse(entry.URL)
		if err != nil {
			continue
		}
		query := parsedURL.Query()
		query.Del("apikey")
		parsedURL.RawQuery = query.Encode()
		urlToID[parsedURL.String()] = entry.ID
	}

	var testCases []testCase
	for _, functions := range functionFiles {
		for _, fn := range functions {
			if len(fn.Examples) == 0 {
				continue
			}

			exampleURL := fn.Examples[0]
			parsedURL, err := url.Parse(exampleURL)
			if err != nil {
				continue
			}

			queryForLookup := parsedURL.Query()
			queryForLookup.Del("apikey")
			parsedURL.RawQuery = queryForLookup.Encode()
			testID, ok := urlToID[parsedURL.String()]
			if !ok {
				testID = fn.Name
			}

			var args []string
			query := parsedURL.Query()
			args = append(args, fn.Name)

			keys := make([]string, 0, len(query))
			for key := range query {
				if key == "function" || key == "apikey" {
					continue
				}
				keys = append(keys, key)
			}
			slices.Sort(keys)

			for _, key := range keys {
				values := query[key]
				flagName := strings.Replace(key, "_", "-", -1)
				flagName = strings.ToLower(flagName)
				if len(values) > 1 {
					args = append(args, fmt.Sprintf("--%s=%s", flagName, strings.Join(values, ",")))
				} else if len(values) == 1 {
					args = append(args, fmt.Sprintf("--%s=%s", flagName, values[0]))
				}
			}

			testCases = append(testCases, testCase{
				Name: testID,
				Args: args,
			})
		}
	}

	slices.SortFunc(testCases, func(a, b testCase) int {
		return cmp.Compare(a.Name, b.Name)
	})

	data, err := json.MarshalIndent(testCases, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal test data: %w", err)
	}

	outputPath := filepath.FromSlash("cmd/av/testdata/args.json")
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("failed to create testdata directory: %w", err)
	}
	if err := os.WriteFile(outputPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write test data: %w", err)
	}

	return nil
}

func newField(tp ast.Expr, ident ...string) *ast.Field {
	var names []*ast.Ident
	for _, name := range ident {
		names = append(names, ast.NewIdent(name))
	}
	return &ast.Field{Names: names, Type: tp}
}

func newSel(x, sel string) *ast.SelectorExpr {
	return &ast.SelectorExpr{
		X:   ast.NewIdent(x),
		Sel: ast.NewIdent(sel),
	}
}

func newSet[T comparable](keys ...T) map[T]struct{} {
	m := make(map[T]struct{}, len(keys))
	for _, key := range keys {
		m[key] = struct{}{}
	}
	return m
}
