// Code generated by github.com/portfoliotree/alphavantage/cmd/generate; DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"github.com/spf13/pflag"
	"github.com/portfoliotree/alphavantage"
)
// RunFunction executes the specified AlphaVantage API function with the given arguments.
func RunFunction(client *alphavantage.Client, functionName string, args []string, output io.Writer) error {
	switch functionName {
	case "AD", "ad":
		return handleChaikinADLine(client, args, output)
	case "ADOSC", "adosc":
		return handleChaikinADOscillator(client, args, output)
	case "ADX", "adx":
		return handleAverageDirectionalMovementIndex(client, args, output)
	case "ADXR", "adxr":
		return handleAverageDirectionalMovementIndexRating(client, args, output)
	case "ALL_COMMODITIES", "all-commodities":
		return handleAllCommodities(client, args, output)
	case "ALUMINUM", "aluminum":
		return handleAluminum(client, args, output)
	case "ANALYTICS_FIXED_WINDOW", "analytics-fixed-window":
		return handleAnalyticsFixedWindow(client, args, output)
	case "ANALYTICS_SLIDING_WINDOW", "analytics-sliding-window":
		return handleAnalyticsSlidingWindow(client, args, output)
	case "APO", "apo":
		return handleAbsolutePriceOscillator(client, args, output)
	case "AROON", "aroon":
		return handleAroon(client, args, output)
	case "AROONOSC", "aroonosc":
		return handleAroonOsc(client, args, output)
	case "ATR", "atr":
		return handleAverageTrueRange(client, args, output)
	case "BALANCE_SHEET", "balance-sheet":
		return handleBalanceSheet(client, args, output)
	case "BBANDS", "bbands":
		return handleBollingerBands(client, args, output)
	case "BOP", "bop":
		return handleBalanceOfPower(client, args, output)
	case "BRENT", "brent":
		return handleBrent(client, args, output)
	case "CASH_FLOW", "cash-flow":
		return handleCashFlow(client, args, output)
	case "CCI", "cci":
		return handleCommodityChannelIndex(client, args, output)
	case "CMO", "cmo":
		return handleChandeMomentumOscillator(client, args, output)
	case "COFFEE", "coffee":
		return handleCoffee(client, args, output)
	case "COPPER", "copper":
		return handleCopper(client, args, output)
	case "CORN", "corn":
		return handleCorn(client, args, output)
	case "COTTON", "cotton":
		return handleCotton(client, args, output)
	case "CPI", "cpi":
		return handleConsumerPriceIndex(client, args, output)
	case "CRYPTO_INTRADAY", "crypto-intraday":
		return handleCryptoIntraday(client, args, output)
	case "CURRENCY_EXCHANGE_RATE", "currency-exchange-rate":
		return handleCurrencyExchangeRate(client, args, output)
	case "DEMA", "dema":
		return handleDoubleExponentialMovingAverage(client, args, output)
	case "DIGITAL_CURRENCY_DAILY", "digital-currency-daily":
		return handleDigitalCurrencyDaily(client, args, output)
	case "DIGITAL_CURRENCY_MONTHLY", "digital-currency-monthly":
		return handleDigitalCurrencyMonthly(client, args, output)
	case "DIGITAL_CURRENCY_WEEKLY", "digital-currency-weekly":
		return handleDigitalCurrencyWeekly(client, args, output)
	case "DIVIDENDS", "dividends":
		return handleDividends(client, args, output)
	case "DURABLES", "durables":
		return handleDurables(client, args, output)
	case "DX", "dx":
		return handleDirectionalMovementIndex(client, args, output)
	case "EARNINGS", "earnings":
		return handleEarnings(client, args, output)
	case "EARNINGS_CALENDAR", "earnings-calendar":
		return handleEarningsCalendar(client, args, output)
	case "EARNINGS_CALL_TRANSCRIPT", "earnings-call-transcript":
		return handleEarningsCallTranscript(client, args, output)
	case "EARNINGS_ESTIMATES", "earnings-estimates":
		return handleEarningsEstimates(client, args, output)
	case "EMA", "ema":
		return handleExponentialMovingAverage(client, args, output)
	case "ETF_PROFILE", "etf-profile":
		return handleETFProfile(client, args, output)
	case "FEDERAL_FUNDS_RATE", "federal-funds-rate":
		return handleFederalFundsRate(client, args, output)
	case "FX_DAILY", "fx-daily":
		return handleFXDaily(client, args, output)
	case "FX_INTRADAY", "fx-intraday":
		return handleFXIntraday(client, args, output)
	case "FX_MONTHLY", "fx-monthly":
		return handleFXMonthly(client, args, output)
	case "FX_WEEKLY", "fx-weekly":
		return handleFXWeekly(client, args, output)
	case "GLOBAL_QUOTE", "global-quote":
		return handleGlobalQuote(client, args, output)
	case "HISTORICAL_OPTIONS", "historical-options":
		return handleHistoricalOptions(client, args, output)
	case "HT_DCPERIOD", "ht-dcperiod":
		return handleHilbertTransformDCPeriod(client, args, output)
	case "HT_DCPHASE", "ht-dcphase":
		return handleHilbertTransformDCPhase(client, args, output)
	case "HT_PHASOR", "ht-phasor":
		return handleHilbertTransformPhasor(client, args, output)
	case "HT_SINE", "ht-sine":
		return handleHilbertTransformSine(client, args, output)
	case "HT_TRENDLINE", "ht-trendline":
		return handleHilbertTransformTrendLine(client, args, output)
	case "HT_TRENDMODE", "ht-trendmode":
		return handleHilbertTransformTrendMode(client, args, output)
	case "INCOME_STATEMENT", "income-statement":
		return handleIncomeStatement(client, args, output)
	case "INFLATION", "inflation":
		return handleInflation(client, args, output)
	case "INSIDER_TRANSACTIONS", "insider-transactions":
		return handleInsiderTransactions(client, args, output)
	case "IPO_CALENDAR", "ipo-calendar":
		return handleIPOCalendar(client, args, output)
	case "KAMA", "kama":
		return handleKaufmanAdaptiveMovingAverage(client, args, output)
	case "LISTING_STATUS", "listing-status":
		return handleListingStatus(client, args, output)
	case "MACD", "macd":
		return handleMovingAverageConvergenceDivergence(client, args, output)
	case "MACDEXT", "macdext":
		return handleMovingAverageConvergenceDivergenceExt(client, args, output)
	case "MAMA", "mama":
		return handleMESAAdaptiveMovingAverage(client, args, output)
	case "MARKET_STATUS", "market-status":
		return handleMarketStatus(client, args, output)
	case "MFI", "mfi":
		return handleMoneyFlowIndex(client, args, output)
	case "MIDPOINT", "midpoint":
		return handleMidPoint(client, args, output)
	case "MIDPRICE", "midprice":
		return handleMidPrice(client, args, output)
	case "MINUS_DI", "minus-di":
		return handleMinusDirectionalIndicator(client, args, output)
	case "MINUS_DM", "minus-dm":
		return handleMinusDirectionalMovement(client, args, output)
	case "MOM", "mom":
		return handleMomentum(client, args, output)
	case "NATR", "natr":
		return handleNormalizedAverageTrueRange(client, args, output)
	case "NATURAL_GAS", "natural-gas":
		return handleNaturalGas(client, args, output)
	case "NEWS_SENTIMENT", "news-sentiment":
		return handleNewsSentiment(client, args, output)
	case "NONFARM_PAYROLL", "nonfarm-payroll":
		return handleNonFarmPayroll(client, args, output)
	case "OBV", "obv":
		return handleOnBalanceVolume(client, args, output)
	case "OVERVIEW", "overview":
		return handleOverview(client, args, output)
	case "PLUS_DI", "plus-di":
		return handlePlusDirectionalIndicator(client, args, output)
	case "PLUS_DM", "plus-dm":
		return handlePlusDirectionalMovement(client, args, output)
	case "PPO", "ppo":
		return handlePercentagePriceOscillator(client, args, output)
	case "REALTIME_BULK_QUOTES", "realtime-bulk-quotes":
		return handleRealtimeBulkQuotes(client, args, output)
	case "REALTIME_OPTIONS", "realtime-options":
		return handleRealtimeOptions(client, args, output)
	case "REAL_GDP", "real-gdp":
		return handleRealGDP(client, args, output)
	case "REAL_GDP_PER_CAPITA", "real-gdp-per-capita":
		return handleRealGDPPerCapita(client, args, output)
	case "RETAIL_SALES", "retail-sales":
		return handleRetailSales(client, args, output)
	case "ROC", "roc":
		return handleRateOfChange(client, args, output)
	case "ROCR", "rocr":
		return handleRateOfChangeRatio(client, args, output)
	case "RSI", "rsi":
		return handleRelativeStrengthIndex(client, args, output)
	case "SAR", "sar":
		return handleSAR(client, args, output)
	case "SHARES_OUTSTANDING", "shares-outstanding":
		return handleSharesOutstanding(client, args, output)
	case "SMA", "sma":
		return handleSimpleMovingAverage(client, args, output)
	case "SPLITS", "splits":
		return handleSplits(client, args, output)
	case "STOCH", "stoch":
		return handleStochasticOscillator(client, args, output)
	case "STOCHF", "stochf":
		return handleStochasticFast(client, args, output)
	case "STOCHRSI", "stochrsi":
		return handleStochasticRelativeStrengthIndex(client, args, output)
	case "SUGAR", "sugar":
		return handleSugar(client, args, output)
	case "SYMBOL_SEARCH", "symbol-search":
		return handleSymbolSearch(client, args, output)
	case "T3", "t3":
		return handleT3(client, args, output)
	case "TEMA", "tema":
		return handleTripleExponentialMovingAverage(client, args, output)
	case "TIME_SERIES_DAILY", "time-series-daily":
		return handleTimeSeriesDaily(client, args, output)
	case "TIME_SERIES_DAILY_ADJUSTED", "time-series-daily-adjusted":
		return handleTimeSeriesDailyAdjusted(client, args, output)
	case "TIME_SERIES_INTRADAY", "time-series-intraday":
		return handleTimeSeriesIntraday(client, args, output)
	case "TIME_SERIES_MONTHLY", "time-series-monthly":
		return handleTimeSeriesMonthly(client, args, output)
	case "TIME_SERIES_MONTHLY_ADJUSTED", "time-series-monthly-adjusted":
		return handleTimeSeriesMonthlyAdjusted(client, args, output)
	case "TIME_SERIES_WEEKLY", "time-series-weekly":
		return handleTimeSeriesWeekly(client, args, output)
	case "TIME_SERIES_WEEKLY_ADJUSTED", "time-series-weekly-adjusted":
		return handleTimeSeriesWeeklyAdjusted(client, args, output)
	case "TOP_GAINERS_LOSERS", "top-gainers-losers":
		return handleTopGainersLosers(client, args, output)
	case "TRANGE", "trange":
		return handleTrueRange(client, args, output)
	case "TREASURY_YIELD", "treasury-yield":
		return handleTreasuryYield(client, args, output)
	case "TRIMA", "trima":
		return handleTriangularMovingAverage(client, args, output)
	case "TRIX", "trix":
		return handleOneDayRateOfChangeTripleSmoothExponentialMovingAverage(client, args, output)
	case "ULTOSC", "ultosc":
		return handleUltimateOscillator(client, args, output)
	case "UNEMPLOYMENT", "unemployment":
		return handleUnemployment(client, args, output)
	case "VWAP", "vwap":
		return handleVolumeWeightedAveragePrice(client, args, output)
	case "WHEAT", "wheat":
		return handleWheat(client, args, output)
	case "WILLR", "willr":
		return handleWilliamsR(client, args, output)
	case "WMA", "wma":
		return handleWeightedMovingAverage(client, args, output)
	case "WTI", "wti":
		return handleWestTexasIntermediate(client, args, output)
	default:
		return fmt.Errorf("unknown function: %s", functionName)
	}
}
func handleChaikinADLine(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("AD", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryChaikinADLine(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetChaikinADLine(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleChaikinADOscillator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ADOSC", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastPeriod int
	flags.IntVar(&fastPeriod, "fastperiod", 0, "")
	var slowPeriod int
	flags.IntVar(&slowPeriod, "slowperiod", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryChaikinADOscillator(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastPeriod != 0 {
		query = query.FastPeriod(strconv.Itoa(fastPeriod))
	}
	if slowPeriod != 0 {
		query = query.SlowPeriod(strconv.Itoa(slowPeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetChaikinADOscillator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAverageDirectionalMovementIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ADX", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryAverageDirectionalMovementIndex(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAverageDirectionalMovementIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAverageDirectionalMovementIndexRating(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ADXR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryAverageDirectionalMovementIndexRating(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAverageDirectionalMovementIndexRating(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAllCommodities(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ALL_COMMODITIES", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly, quarterly, annual")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryAllCommodities(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAllCommodities(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAluminum(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ALUMINUM", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly, quarterly, annual")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryAluminum(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAluminum(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAnalyticsFixedWindow(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ANALYTICS_FIXED_WINDOW", pflag.ContinueOnError)
	var symbols string
	flags.StringVar(&symbols, "symbols", "", "[REQUIRED]")
	var rng string
	flags.StringVar(&rng, "range", "", "[REQUIRED]")
	var intervalAnalytics string
	flags.StringVar(&intervalAnalytics, "interval", "", "[REQUIRED]")
	var calculations string
	flags.StringVar(&calculations, "calculations", "", "[REQUIRED]")
	var openHighLowClose string
	flags.StringVar(&openHighLowClose, "ohlc", "", "options: open, high, low, close")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbols == "" {
		return fmt.Errorf("required flag --symbols not set")
	}
	if rng == "" {
		return fmt.Errorf("required flag --range not set")
	}
	if intervalAnalytics == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if calculations == "" {
		return fmt.Errorf("required flag --calculations not set")
	}
	query := alphavantage.QueryAnalyticsFixedWindow(client.APIKey, symbols, rng, intervalAnalytics, calculations)
	if openHighLowClose != "" {
		query = query.OHLC(openHighLowClose)
	}
	ctx := context.Background()
	res, err := client.GetAnalyticsFixedWindow(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAnalyticsSlidingWindow(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ANALYTICS_SLIDING_WINDOW", pflag.ContinueOnError)
	var symbols string
	flags.StringVar(&symbols, "symbols", "", "[REQUIRED]")
	var rng string
	flags.StringVar(&rng, "range", "", "[REQUIRED]")
	var intervalAnalytics string
	flags.StringVar(&intervalAnalytics, "interval", "", "[REQUIRED]")
	var windowSize string
	flags.StringVar(&windowSize, "window-size", "", "[REQUIRED]")
	var calculations string
	flags.StringVar(&calculations, "calculations", "", "[REQUIRED]")
	var openHighLowClose string
	flags.StringVar(&openHighLowClose, "ohlc", "", "options: open, high, low, close")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbols == "" {
		return fmt.Errorf("required flag --symbols not set")
	}
	if rng == "" {
		return fmt.Errorf("required flag --range not set")
	}
	if intervalAnalytics == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if windowSize == "" {
		return fmt.Errorf("required flag --window-size not set")
	}
	if calculations == "" {
		return fmt.Errorf("required flag --calculations not set")
	}
	query := alphavantage.QueryAnalyticsSlidingWindow(client.APIKey, symbols, rng, intervalAnalytics, windowSize, calculations)
	if openHighLowClose != "" {
		query = query.OHLC(openHighLowClose)
	}
	ctx := context.Background()
	res, err := client.GetAnalyticsSlidingWindow(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAbsolutePriceOscillator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("APO", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastPeriod int
	flags.IntVar(&fastPeriod, "fastperiod", 0, "")
	var slowPeriod int
	flags.IntVar(&slowPeriod, "slowperiod", 0, "")
	var movingAverageType int
	flags.IntVar(&movingAverageType, "matype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryAbsolutePriceOscillator(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastPeriod != 0 {
		query = query.FastPeriod(strconv.Itoa(fastPeriod))
	}
	if slowPeriod != 0 {
		query = query.SlowPeriod(strconv.Itoa(slowPeriod))
	}
	if movingAverageType != 0 {
		query = query.MovingAverageType(strconv.Itoa(movingAverageType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAbsolutePriceOscillator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAroon(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("AROON", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryAroon(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAroon(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAroonOsc(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("AROONOSC", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryAroonOsc(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAroonOsc(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleAverageTrueRange(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ATR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryAverageTrueRange(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetAverageTrueRange(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleBalanceSheet(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("BALANCE_SHEET", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryBalanceSheet(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetBalanceSheet(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleBollingerBands(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("BBANDS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var upperBandStandardDeviationMultiplier string
	flags.StringVar(&upperBandStandardDeviationMultiplier, "nbdevup", "", "")
	var lowerBandStandardDeviationMultiplier string
	flags.StringVar(&lowerBandStandardDeviationMultiplier, "nbdevdn", "", "")
	var movingAverageType int
	flags.IntVar(&movingAverageType, "matype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryBollingerBands(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if upperBandStandardDeviationMultiplier != "" {
		query = query.UpperBandStandardDeviationMultiplier(upperBandStandardDeviationMultiplier)
	}
	if lowerBandStandardDeviationMultiplier != "" {
		query = query.LowerBandStandardDeviationMultiplier(lowerBandStandardDeviationMultiplier)
	}
	if movingAverageType != 0 {
		query = query.MovingAverageType(strconv.Itoa(movingAverageType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetBollingerBands(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleBalanceOfPower(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("BOP", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryBalanceOfPower(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetBalanceOfPower(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleBrent(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("BRENT", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryBrent(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetBrent(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCashFlow(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CASH_FLOW", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryCashFlow(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetCashFlow(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCommodityChannelIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CCI", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryCommodityChannelIndex(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetCommodityChannelIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleChandeMomentumOscillator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CMO", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryChandeMomentumOscillator(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetChandeMomentumOscillator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCoffee(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("COFFEE", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryCoffee(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetCoffee(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCopper(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("COPPER", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryCopper(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetCopper(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCorn(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CORN", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryCorn(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetCorn(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCotton(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("COTTON", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryCotton(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetCotton(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleConsumerPriceIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CPI", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: monthly, semiannual")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryConsumerPriceIndex(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetConsumerPriceIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCryptoIntraday(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CRYPTO_INTRADAY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var market string
	flags.StringVar(&market, "market", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: 1min, 5min, 15min, 30min, 60min")
	var outputSize string
	flags.StringVar(&outputSize, "outputsize", "", "options: compact, full")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if market == "" {
		return fmt.Errorf("required flag --market not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryCryptoIntraday(client.APIKey, symbol, market, interval)
	if outputSize != "" {
		query = query.OutputSize(outputSize)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetCryptoIntraday(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleCurrencyExchangeRate(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("CURRENCY_EXCHANGE_RATE", pflag.ContinueOnError)
	var fromCurrency string
	flags.StringVar(&fromCurrency, "from-currency", "", "[REQUIRED]")
	var toCurrency string
	flags.StringVar(&toCurrency, "to-currency", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if fromCurrency == "" {
		return fmt.Errorf("required flag --from-currency not set")
	}
	if toCurrency == "" {
		return fmt.Errorf("required flag --to-currency not set")
	}
	query := alphavantage.QueryCurrencyExchangeRate(client.APIKey, fromCurrency, toCurrency)
	ctx := context.Background()
	res, err := client.GetCurrencyExchangeRate(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDoubleExponentialMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DEMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryDoubleExponentialMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetDoubleExponentialMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDigitalCurrencyDaily(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DIGITAL_CURRENCY_DAILY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var market string
	flags.StringVar(&market, "market", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if market == "" {
		return fmt.Errorf("required flag --market not set")
	}
	query := alphavantage.QueryDigitalCurrencyDaily(client.APIKey, symbol, market)
	ctx := context.Background()
	res, err := client.GetDigitalCurrencyDaily(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDigitalCurrencyMonthly(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DIGITAL_CURRENCY_MONTHLY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var market string
	flags.StringVar(&market, "market", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if market == "" {
		return fmt.Errorf("required flag --market not set")
	}
	query := alphavantage.QueryDigitalCurrencyMonthly(client.APIKey, symbol, market)
	ctx := context.Background()
	res, err := client.GetDigitalCurrencyMonthly(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDigitalCurrencyWeekly(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DIGITAL_CURRENCY_WEEKLY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var market string
	flags.StringVar(&market, "market", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if market == "" {
		return fmt.Errorf("required flag --market not set")
	}
	query := alphavantage.QueryDigitalCurrencyWeekly(client.APIKey, symbol, market)
	ctx := context.Background()
	res, err := client.GetDigitalCurrencyWeekly(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDividends(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DIVIDENDS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryDividends(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetDividends(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDurables(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DURABLES", pflag.ContinueOnError)
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryDurables(client.APIKey)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetDurables(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleDirectionalMovementIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("DX", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryDirectionalMovementIndex(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetDirectionalMovementIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleEarnings(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("EARNINGS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryEarnings(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetEarnings(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleEarningsCalendar(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("EARNINGS_CALENDAR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "")
	var horizon string
	flags.StringVar(&horizon, "horizon", "", "options: 3month, 6month, 12month")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryEarningsCalendar(client.APIKey)
	if symbol != "" {
		query = query.Symbol(symbol)
	}
	if horizon != "" {
		query = query.Horizon(horizon)
	}
	ctx := context.Background()
	res, err := client.GetEarningsCalendar(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleEarningsCallTranscript(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("EARNINGS_CALL_TRANSCRIPT", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var quarter string
	flags.StringVar(&quarter, "quarter", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if quarter == "" {
		return fmt.Errorf("required flag --quarter not set")
	}
	query := alphavantage.QueryEarningsCallTranscript(client.APIKey, symbol, quarter)
	ctx := context.Background()
	res, err := client.GetEarningsCallTranscript(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleEarningsEstimates(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("EARNINGS_ESTIMATES", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryEarningsEstimates(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetEarningsEstimates(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleExponentialMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("EMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryExponentialMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetExponentialMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleETFProfile(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ETF_PROFILE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryETFProfile(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetETFProfile(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleFederalFundsRate(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("FEDERAL_FUNDS_RATE", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryFederalFundsRate(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetFederalFundsRate(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleFXDaily(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("FX_DAILY", pflag.ContinueOnError)
	var fromSymbol string
	flags.StringVar(&fromSymbol, "from-symbol", "", "[REQUIRED]")
	var toSymbol string
	flags.StringVar(&toSymbol, "to-symbol", "", "[REQUIRED]")
	var outputSize string
	flags.StringVar(&outputSize, "outputsize", "", "options: compact, full")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if fromSymbol == "" {
		return fmt.Errorf("required flag --from-symbol not set")
	}
	if toSymbol == "" {
		return fmt.Errorf("required flag --to-symbol not set")
	}
	query := alphavantage.QueryFXDaily(client.APIKey, fromSymbol, toSymbol)
	if outputSize != "" {
		query = query.OutputSize(outputSize)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetFXDaily(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleFXIntraday(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("FX_INTRADAY", pflag.ContinueOnError)
	var fromSymbol string
	flags.StringVar(&fromSymbol, "from-symbol", "", "[REQUIRED]")
	var toSymbol string
	flags.StringVar(&toSymbol, "to-symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: 1min, 5min, 15min, 30min, 60min")
	var outputSize string
	flags.StringVar(&outputSize, "outputsize", "", "options: compact, full")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if fromSymbol == "" {
		return fmt.Errorf("required flag --from-symbol not set")
	}
	if toSymbol == "" {
		return fmt.Errorf("required flag --to-symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryFXIntraday(client.APIKey, fromSymbol, toSymbol, interval)
	if outputSize != "" {
		query = query.OutputSize(outputSize)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetFXIntraday(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleFXMonthly(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("FX_MONTHLY", pflag.ContinueOnError)
	var fromSymbol string
	flags.StringVar(&fromSymbol, "from-symbol", "", "[REQUIRED]")
	var toSymbol string
	flags.StringVar(&toSymbol, "to-symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if fromSymbol == "" {
		return fmt.Errorf("required flag --from-symbol not set")
	}
	if toSymbol == "" {
		return fmt.Errorf("required flag --to-symbol not set")
	}
	query := alphavantage.QueryFXMonthly(client.APIKey, fromSymbol, toSymbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetFXMonthly(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleFXWeekly(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("FX_WEEKLY", pflag.ContinueOnError)
	var fromSymbol string
	flags.StringVar(&fromSymbol, "from-symbol", "", "[REQUIRED]")
	var toSymbol string
	flags.StringVar(&toSymbol, "to-symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if fromSymbol == "" {
		return fmt.Errorf("required flag --from-symbol not set")
	}
	if toSymbol == "" {
		return fmt.Errorf("required flag --to-symbol not set")
	}
	query := alphavantage.QueryFXWeekly(client.APIKey, fromSymbol, toSymbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetFXWeekly(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleGlobalQuote(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("GLOBAL_QUOTE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryGlobalQuote(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetGlobalQuote(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHistoricalOptions(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HISTORICAL_OPTIONS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var date string
	flags.StringVar(&date, "date", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryHistoricalOptions(client.APIKey, symbol)
	if date != "" {
		query = query.Date(date)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHistoricalOptions(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHilbertTransformDCPeriod(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HT_DCPERIOD", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryHilbertTransformDCPeriod(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHilbertTransformDCPeriod(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHilbertTransformDCPhase(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HT_DCPHASE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryHilbertTransformDCPhase(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHilbertTransformDCPhase(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHilbertTransformPhasor(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HT_PHASOR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryHilbertTransformPhasor(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHilbertTransformPhasor(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHilbertTransformSine(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HT_SINE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryHilbertTransformSine(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHilbertTransformSine(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHilbertTransformTrendLine(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HT_TRENDLINE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryHilbertTransformTrendLine(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHilbertTransformTrendLine(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleHilbertTransformTrendMode(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("HT_TRENDMODE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryHilbertTransformTrendMode(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetHilbertTransformTrendMode(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleIncomeStatement(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("INCOME_STATEMENT", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryIncomeStatement(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetIncomeStatement(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleInflation(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("INFLATION", pflag.ContinueOnError)
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryInflation(client.APIKey)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetInflation(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleInsiderTransactions(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("INSIDER_TRANSACTIONS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryInsiderTransactions(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetInsiderTransactions(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleIPOCalendar(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("IPO_CALENDAR", pflag.ContinueOnError)
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryIPOCalendar(client.APIKey)
	ctx := context.Background()
	res, err := client.GetIPOCalendar(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleKaufmanAdaptiveMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("KAMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryKaufmanAdaptiveMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetKaufmanAdaptiveMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleListingStatus(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("LISTING_STATUS", pflag.ContinueOnError)
	var date string
	flags.StringVar(&date, "date", "", "")
	var state string
	flags.StringVar(&state, "state", "", "options: active, delisted")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryListingStatus(client.APIKey)
	if date != "" {
		query = query.Date(date)
	}
	if state != "" {
		query = query.State(state)
	}
	ctx := context.Background()
	res, err := client.GetListingStatus(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMovingAverageConvergenceDivergence(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MACD", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastPeriod int
	flags.IntVar(&fastPeriod, "fastperiod", 0, "")
	var slowPeriod int
	flags.IntVar(&slowPeriod, "slowperiod", 0, "")
	var signalPeriod int
	flags.IntVar(&signalPeriod, "signalperiod", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryMovingAverageConvergenceDivergence(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastPeriod != 0 {
		query = query.FastPeriod(strconv.Itoa(fastPeriod))
	}
	if slowPeriod != 0 {
		query = query.SlowPeriod(strconv.Itoa(slowPeriod))
	}
	if signalPeriod != 0 {
		query = query.SignalPeriod(strconv.Itoa(signalPeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMovingAverageConvergenceDivergence(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMovingAverageConvergenceDivergenceExt(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MACDEXT", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastPeriod int
	flags.IntVar(&fastPeriod, "fastperiod", 0, "")
	var slowPeriod int
	flags.IntVar(&slowPeriod, "slowperiod", 0, "")
	var signalPeriod int
	flags.IntVar(&signalPeriod, "signalperiod", 0, "")
	var fastMAType int
	flags.IntVar(&fastMAType, "fastmatype", 0, "")
	var slowMAType int
	flags.IntVar(&slowMAType, "slowmatype", 0, "")
	var signalMAType int
	flags.IntVar(&signalMAType, "signalmatype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryMovingAverageConvergenceDivergenceExt(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastPeriod != 0 {
		query = query.FastPeriod(strconv.Itoa(fastPeriod))
	}
	if slowPeriod != 0 {
		query = query.SlowPeriod(strconv.Itoa(slowPeriod))
	}
	if signalPeriod != 0 {
		query = query.SignalPeriod(strconv.Itoa(signalPeriod))
	}
	if fastMAType != 0 {
		query = query.FastMAType(strconv.Itoa(fastMAType))
	}
	if slowMAType != 0 {
		query = query.SlowMAType(strconv.Itoa(slowMAType))
	}
	if signalMAType != 0 {
		query = query.SignalMAType(strconv.Itoa(signalMAType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMovingAverageConvergenceDivergenceExt(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMESAAdaptiveMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MAMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastLimit string
	flags.StringVar(&fastLimit, "fastlimit", "", "")
	var slowLimit string
	flags.StringVar(&slowLimit, "slowlimit", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryMESAAdaptiveMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastLimit != "" {
		query = query.FastLimit(fastLimit)
	}
	if slowLimit != "" {
		query = query.SlowLimit(slowLimit)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMESAAdaptiveMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMarketStatus(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MARKET_STATUS", pflag.ContinueOnError)
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryMarketStatus(client.APIKey)
	ctx := context.Background()
	res, err := client.GetMarketStatus(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMoneyFlowIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MFI", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryMoneyFlowIndex(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMoneyFlowIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMidPoint(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MIDPOINT", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "[REQUIRED]")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if timePeriod == 0 {
		return fmt.Errorf("required flag --time-period not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryMidPoint(client.APIKey, symbol, interval, strconv.Itoa(timePeriod), seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMidPoint(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMidPrice(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MIDPRICE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "[REQUIRED]")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if timePeriod == 0 {
		return fmt.Errorf("required flag --time-period not set")
	}
	query := alphavantage.QueryMidPrice(client.APIKey, symbol, interval, strconv.Itoa(timePeriod))
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMidPrice(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMinusDirectionalIndicator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MINUS_DI", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryMinusDirectionalIndicator(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMinusDirectionalIndicator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMinusDirectionalMovement(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MINUS_DM", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryMinusDirectionalMovement(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMinusDirectionalMovement(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleMomentum(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("MOM", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryMomentum(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetMomentum(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleNormalizedAverageTrueRange(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("NATR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryNormalizedAverageTrueRange(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetNormalizedAverageTrueRange(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleNaturalGas(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("NATURAL_GAS", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryNaturalGas(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetNaturalGas(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleNewsSentiment(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("NEWS_SENTIMENT", pflag.ContinueOnError)
	var tickers string
	flags.StringVar(&tickers, "tickers", "", "")
	var topics string
	flags.StringVar(&topics, "topics", "", "")
	var timeFrom string
	flags.StringVar(&timeFrom, "time-from", "", "")
	var timeTo string
	flags.StringVar(&timeTo, "time-to", "", "")
	var sort string
	flags.StringVar(&sort, "sort", "", "options: LATEST, EARLIEST, RELEVANCE")
	var limit int
	flags.IntVar(&limit, "limit", 0, "")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryNewsSentiment(client.APIKey)
	if tickers != "" {
		query = query.Tickers(tickers)
	}
	if topics != "" {
		query = query.Topics(topics)
	}
	if timeFrom != "" {
		t, err := time.Parse("2006-01", timeFrom)
		if err != nil {
			return fmt.Errorf("invalid time_from format: %w", err)
		}
		query = query.TimeFrom(t)
	}
	if timeTo != "" {
		t, err := time.Parse("2006-01", timeTo)
		if err != nil {
			return fmt.Errorf("invalid time_to format: %w", err)
		}
		query = query.TimeTo(t)
	}
	if sort != "" {
		query = query.Sort(sort)
	}
	if limit != 0 {
		query = query.Limit(strconv.Itoa(limit))
	}
	ctx := context.Background()
	res, err := client.GetNewsSentiment(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleNonFarmPayroll(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("NONFARM_PAYROLL", pflag.ContinueOnError)
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryNonFarmPayroll(client.APIKey)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetNonFarmPayroll(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleOnBalanceVolume(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("OBV", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryOnBalanceVolume(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetOnBalanceVolume(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleOverview(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("OVERVIEW", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryOverview(client.APIKey, symbol)
	ctx := context.Background()
	res, err := client.GetOverview(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handlePlusDirectionalIndicator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("PLUS_DI", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryPlusDirectionalIndicator(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetPlusDirectionalIndicator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handlePlusDirectionalMovement(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("PLUS_DM", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryPlusDirectionalMovement(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetPlusDirectionalMovement(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handlePercentagePriceOscillator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("PPO", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastPeriod int
	flags.IntVar(&fastPeriod, "fastperiod", 0, "")
	var slowPeriod int
	flags.IntVar(&slowPeriod, "slowperiod", 0, "")
	var movingAverageType int
	flags.IntVar(&movingAverageType, "matype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryPercentagePriceOscillator(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastPeriod != 0 {
		query = query.FastPeriod(strconv.Itoa(fastPeriod))
	}
	if slowPeriod != 0 {
		query = query.SlowPeriod(strconv.Itoa(slowPeriod))
	}
	if movingAverageType != 0 {
		query = query.MovingAverageType(strconv.Itoa(movingAverageType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetPercentagePriceOscillator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRealtimeBulkQuotes(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("REALTIME_BULK_QUOTES", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryRealtimeBulkQuotes(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRealtimeBulkQuotes(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRealtimeOptions(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("REALTIME_OPTIONS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var requireGreeks bool
	flags.BoolVar(&requireGreeks, "require-greeks", false, "")
	var contract string
	flags.StringVar(&contract, "contract", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryRealtimeOptions(client.APIKey, symbol)
	if requireGreeks {
		query = query.RequireGreeks(requireGreeks)
	}
	if contract != "" {
		query = query.Contract(contract)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRealtimeOptions(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRealGDP(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("REAL_GDP", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: quarterly, annual")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryRealGDP(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRealGDP(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRealGDPPerCapita(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("REAL_GDP_PER_CAPITA", pflag.ContinueOnError)
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryRealGDPPerCapita(client.APIKey)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRealGDPPerCapita(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRetailSales(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("RETAIL_SALES", pflag.ContinueOnError)
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryRetailSales(client.APIKey)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRetailSales(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRateOfChange(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ROC", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryRateOfChange(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRateOfChange(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRateOfChangeRatio(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ROCR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryRateOfChangeRatio(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRateOfChangeRatio(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleRelativeStrengthIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("RSI", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryRelativeStrengthIndex(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetRelativeStrengthIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleSAR(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("SAR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var acceleration string
	flags.StringVar(&acceleration, "acceleration", "", "")
	var maximum string
	flags.StringVar(&maximum, "maximum", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QuerySAR(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if acceleration != "" {
		query = query.Acceleration(acceleration)
	}
	if maximum != "" {
		query = query.Maximum(maximum)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetSAR(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleSharesOutstanding(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("SHARES_OUTSTANDING", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QuerySharesOutstanding(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetSharesOutstanding(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleSimpleMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("SMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QuerySimpleMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetSimpleMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleSplits(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("SPLITS", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QuerySplits(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetSplits(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleStochasticOscillator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("STOCH", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastKPeriod int
	flags.IntVar(&fastKPeriod, "fastkperiod", 0, "")
	var slowKPeriod int
	flags.IntVar(&slowKPeriod, "slowkperiod", 0, "")
	var slowDPeriod int
	flags.IntVar(&slowDPeriod, "slowdperiod", 0, "")
	var slowKMAType int
	flags.IntVar(&slowKMAType, "slowkmatype", 0, "")
	var slowDMAType int
	flags.IntVar(&slowDMAType, "slowdmatype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryStochasticOscillator(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastKPeriod != 0 {
		query = query.FastKPeriod(strconv.Itoa(fastKPeriod))
	}
	if slowKPeriod != 0 {
		query = query.SlowKPeriod(strconv.Itoa(slowKPeriod))
	}
	if slowDPeriod != 0 {
		query = query.SlowDPeriod(strconv.Itoa(slowDPeriod))
	}
	if slowKMAType != 0 {
		query = query.SlowKMAType(strconv.Itoa(slowKMAType))
	}
	if slowDMAType != 0 {
		query = query.SlowDMAType(strconv.Itoa(slowDMAType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetStochasticOscillator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleStochasticFast(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("STOCHF", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var fastKPeriod int
	flags.IntVar(&fastKPeriod, "fastkperiod", 0, "")
	var fastDPeriod int
	flags.IntVar(&fastDPeriod, "fastdperiod", 0, "")
	var fastDMAType int
	flags.IntVar(&fastDMAType, "fastdmatype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryStochasticFast(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if fastKPeriod != 0 {
		query = query.FastKPeriod(strconv.Itoa(fastKPeriod))
	}
	if fastDPeriod != 0 {
		query = query.FastDPeriod(strconv.Itoa(fastDPeriod))
	}
	if fastDMAType != 0 {
		query = query.FastDMAType(strconv.Itoa(fastDMAType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetStochasticFast(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleStochasticRelativeStrengthIndex(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("STOCHRSI", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var fastKPeriod int
	flags.IntVar(&fastKPeriod, "fastkperiod", 0, "")
	var fastDPeriod int
	flags.IntVar(&fastDPeriod, "fastdperiod", 0, "")
	var fastDMAType int
	flags.IntVar(&fastDMAType, "fastdmatype", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryStochasticRelativeStrengthIndex(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if fastKPeriod != 0 {
		query = query.FastKPeriod(strconv.Itoa(fastKPeriod))
	}
	if fastDPeriod != 0 {
		query = query.FastDPeriod(strconv.Itoa(fastDPeriod))
	}
	if fastDMAType != 0 {
		query = query.FastDMAType(strconv.Itoa(fastDMAType))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetStochasticRelativeStrengthIndex(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleSugar(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("SUGAR", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QuerySugar(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetSugar(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleSymbolSearch(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("SYMBOL_SEARCH", pflag.ContinueOnError)
	var keywords string
	flags.StringVar(&keywords, "keywords", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if keywords == "" {
		return fmt.Errorf("required flag --keywords not set")
	}
	query := alphavantage.QuerySymbolSearch(client.APIKey, keywords)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetSymbolSearch(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleT3(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("T3", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryT3(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetT3(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTripleExponentialMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TEMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryTripleExponentialMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTripleExponentialMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesDaily(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_DAILY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var outputSize string
	flags.StringVar(&outputSize, "outputsize", "", "options: compact, full")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryTimeSeriesDaily(client.APIKey, symbol)
	if outputSize != "" {
		query = query.OutputSize(outputSize)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesDaily(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesDailyAdjusted(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_DAILY_ADJUSTED", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var outputSize string
	flags.StringVar(&outputSize, "outputsize", "", "options: compact, full")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryTimeSeriesDailyAdjusted(client.APIKey, symbol)
	if outputSize != "" {
		query = query.OutputSize(outputSize)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesDailyAdjusted(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesIntraday(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_INTRADAY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: 1min, 5min, 15min, 30min, 60min")
	var adjusted bool
	flags.BoolVar(&adjusted, "adjusted", false, "")
	var extendedHours bool
	flags.BoolVar(&extendedHours, "extended-hours", false, "")
	var month string
	flags.StringVar(&month, "month", "", "")
	var outputSize string
	flags.StringVar(&outputSize, "outputsize", "", "options: compact, full")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryTimeSeriesIntraday(client.APIKey, symbol, interval)
	if adjusted {
		query = query.Adjusted(adjusted)
	}
	if extendedHours {
		query = query.ExtendedHours(extendedHours)
	}
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if outputSize != "" {
		query = query.OutputSize(outputSize)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesIntraday(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesMonthly(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_MONTHLY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryTimeSeriesMonthly(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesMonthly(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesMonthlyAdjusted(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_MONTHLY_ADJUSTED", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryTimeSeriesMonthlyAdjusted(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesMonthlyAdjusted(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesWeekly(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_WEEKLY", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryTimeSeriesWeekly(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesWeekly(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTimeSeriesWeeklyAdjusted(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TIME_SERIES_WEEKLY_ADJUSTED", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	query := alphavantage.QueryTimeSeriesWeeklyAdjusted(client.APIKey, symbol)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTimeSeriesWeeklyAdjusted(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTopGainersLosers(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TOP_GAINERS_LOSERS", pflag.ContinueOnError)
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryTopGainersLosers(client.APIKey)
	ctx := context.Background()
	res, err := client.GetTopGainersLosers(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTrueRange(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TRANGE", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryTrueRange(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTrueRange(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTreasuryYield(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TREASURY_YIELD", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var maturity string
	flags.StringVar(&maturity, "maturity", "", "options: 3month, 2year, 5year, 7year, 10year, 30year")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryTreasuryYield(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if maturity != "" {
		query = query.Maturity(maturity)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTreasuryYield(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleTriangularMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TRIMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryTriangularMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetTriangularMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleOneDayRateOfChangeTripleSmoothExponentialMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("TRIX", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryOneDayRateOfChangeTripleSmoothExponentialMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetOneDayRateOfChangeTripleSmoothExponentialMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleUltimateOscillator(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("ULTOSC", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod1 int
	flags.IntVar(&timePeriod1, "timeperiod1", 0, "")
	var timePeriod2 int
	flags.IntVar(&timePeriod2, "timeperiod2", 0, "")
	var timePeriod3 int
	flags.IntVar(&timePeriod3, "timeperiod3", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryUltimateOscillator(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod1 != 0 {
		query = query.TimePeriod1(strconv.Itoa(timePeriod1))
	}
	if timePeriod2 != 0 {
		query = query.TimePeriod2(strconv.Itoa(timePeriod2))
	}
	if timePeriod3 != 0 {
		query = query.TimePeriod3(strconv.Itoa(timePeriod3))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetUltimateOscillator(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleUnemployment(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("UNEMPLOYMENT", pflag.ContinueOnError)
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryUnemployment(client.APIKey)
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetUnemployment(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleVolumeWeightedAveragePrice(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("VWAP", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: 1min, 5min, 15min, 30min, 60min")
	var month string
	flags.StringVar(&month, "month", "", "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryVolumeWeightedAveragePrice(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetVolumeWeightedAveragePrice(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleWheat(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("WHEAT", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryWheat(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetWheat(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleWilliamsR(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("WILLR", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	query := alphavantage.QueryWilliamsR(client.APIKey, symbol, interval)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetWilliamsR(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleWeightedMovingAverage(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("WMA", pflag.ContinueOnError)
	var symbol string
	flags.StringVar(&symbol, "symbol", "", "[REQUIRED]")
	var interval string
	flags.StringVar(&interval, "interval", "", "[REQUIRED] options: daily, weekly, monthly")
	var seriesType string
	flags.StringVar(&seriesType, "series-type", "", "[REQUIRED] options: close, open, high, low")
	var month string
	flags.StringVar(&month, "month", "", "")
	var timePeriod int
	flags.IntVar(&timePeriod, "time-period", 0, "")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	if symbol == "" {
		return fmt.Errorf("required flag --symbol not set")
	}
	if interval == "" {
		return fmt.Errorf("required flag --interval not set")
	}
	if seriesType == "" {
		return fmt.Errorf("required flag --series-type not set")
	}
	query := alphavantage.QueryWeightedMovingAverage(client.APIKey, symbol, interval, seriesType)
	if month != "" {
		t, err := time.Parse("2006-01", month)
		if err != nil {
			return fmt.Errorf("invalid month format: %w", err)
		}
		query = query.Month(t)
	}
	if timePeriod != 0 {
		query = query.TimePeriod(strconv.Itoa(timePeriod))
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetWeightedMovingAverage(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
func handleWestTexasIntermediate(client *alphavantage.Client, args []string, output io.Writer) error {
	flags := pflag.NewFlagSet("WTI", pflag.ContinueOnError)
	var interval string
	flags.StringVar(&interval, "interval", "", "options: daily, weekly, monthly")
	var dataType string
	flags.StringVar(&dataType, "datatype", "", "options: csv, json")
	if err := flags.Parse(args); err != nil {
		return err
	}
	query := alphavantage.QueryWestTexasIntermediate(client.APIKey)
	if interval != "" {
		query = query.Interval(interval)
	}
	if dataType != "" {
		query = query.DataType(dataType)
	}
	ctx := context.Background()
	res, err := client.GetWestTexasIntermediate(ctx, query)
	if err != nil {
		return fmt.Errorf("API request failed: %w", err)
	}
	defer res.Body.Close()
	if _, err := io.Copy(output, res.Body); err != nil {
		return fmt.Errorf("failed to write response: %w", err)
	}
	return nil
}
