// Code generated by av-generate; DO NOT EDIT.

package alphavantage

import (
	"context"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

type GlobalQuoteQuery url.Values

func QueryGlobalQuote(apiKey, symbol string) GlobalQuoteQuery {
	return GlobalQuoteQuery{"function": []string{"GLOBAL_QUOTE"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query GlobalQuoteQuery) DataTypeCSV() GlobalQuoteQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query GlobalQuoteQuery) DataTypeJSON() GlobalQuoteQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query GlobalQuoteQuery) DataType(value string) GlobalQuoteQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetGlobalQuote(ctx context.Context, q GlobalQuoteQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type GlobalQuoteRow struct {
	Symbol        string `column-name:"symbol"`
	Open          string `column-name:"open"`
	High          string `column-name:"high"`
	Low           string `column-name:"low"`
	Price         string `column-name:"price"`
	Volume        string `column-name:"volume"`
	LatestDay     string `column-name:"latestDay"`
	PreviousClose string `column-name:"previousClose"`
	Change        string `column-name:"change"`
	ChangePercent string `column-name:"changePercent"`
}

func (client *Client) GetGlobalQuoteCSVRows(ctx context.Context, q GlobalQuoteQuery) ([]GlobalQuoteRow, error) {
	q.DataTypeCSV()
	res, err := client.GetGlobalQuote(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []GlobalQuoteRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type MarketStatusQuery url.Values

func QueryMarketStatus(apiKey string) MarketStatusQuery {
	return MarketStatusQuery{"function": []string{"MARKET_STATUS"}, "apikey": []string{apiKey}}
}

func (client *Client) GetMarketStatus(ctx context.Context, q MarketStatusQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type RealtimeBulkQuotesQuery url.Values

func QueryRealtimeBulkQuotes(apiKey, symbol string) RealtimeBulkQuotesQuery {
	return RealtimeBulkQuotesQuery{"function": []string{"REALTIME_BULK_QUOTES"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query RealtimeBulkQuotesQuery) DataTypeCSV() RealtimeBulkQuotesQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query RealtimeBulkQuotesQuery) DataTypeJSON() RealtimeBulkQuotesQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query RealtimeBulkQuotesQuery) DataType(value string) RealtimeBulkQuotesQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetRealtimeBulkQuotes(ctx context.Context, q RealtimeBulkQuotesQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type SymbolSearchQuery url.Values

func QuerySymbolSearch(apiKey, keywords string) SymbolSearchQuery {
	return SymbolSearchQuery{"function": []string{"SYMBOL_SEARCH"}, "keywords": []string{keywords}, "apikey": []string{apiKey}}
}

func (query SymbolSearchQuery) DataTypeCSV() SymbolSearchQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query SymbolSearchQuery) DataTypeJSON() SymbolSearchQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query SymbolSearchQuery) DataType(value string) SymbolSearchQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetSymbolSearch(ctx context.Context, q SymbolSearchQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type SymbolSearchRow struct {
	Symbol      string  `column-name:"symbol"`
	Name        string  `column-name:"name"`
	Type        string  `column-name:"type"`
	Region      string  `column-name:"region"`
	MarketOpen  string  `column-name:"marketOpen"`
	MarketClose string  `column-name:"marketClose"`
	TimeZone    string  `column-name:"timezone"`
	Currency    string  `column-name:"currency"`
	MatchScore  float64 `column-name:"matchScore"`
}

func (client *Client) GetSymbolSearchCSVRows(ctx context.Context, q SymbolSearchQuery) ([]SymbolSearchRow, error) {
	q.DataTypeCSV()
	res, err := client.GetSymbolSearch(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []SymbolSearchRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesDailyQuery url.Values

func QueryTimeSeriesDaily(apiKey, symbol string) TimeSeriesDailyQuery {
	return TimeSeriesDailyQuery{"function": []string{"TIME_SERIES_DAILY"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query TimeSeriesDailyQuery) OutputSizeCompact() TimeSeriesDailyQuery {
	query["outputsize"] = []string{"compact"}
	return query
}

func (query TimeSeriesDailyQuery) OutputSizeFull() TimeSeriesDailyQuery {
	query["outputsize"] = []string{"full"}
	return query
}

func (query TimeSeriesDailyQuery) OutputSize(value string) TimeSeriesDailyQuery {
	query["outputsize"] = []string{value}
	return query
}

func (query TimeSeriesDailyQuery) DataTypeCSV() TimeSeriesDailyQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesDailyQuery) DataTypeJSON() TimeSeriesDailyQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesDailyQuery) DataType(value string) TimeSeriesDailyQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesDaily(ctx context.Context, q TimeSeriesDailyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesDailyRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    int       `column-name:"volume"`
}

func (client *Client) GetTimeSeriesDailyCSVRows(ctx context.Context, q TimeSeriesDailyQuery) ([]TimeSeriesDailyRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesDaily(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesDailyRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesDailyAdjustedQuery url.Values

func QueryTimeSeriesDailyAdjusted(apiKey, symbol string) TimeSeriesDailyAdjustedQuery {
	return TimeSeriesDailyAdjustedQuery{"function": []string{"TIME_SERIES_DAILY_ADJUSTED"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query TimeSeriesDailyAdjustedQuery) OutputSizeCompact() TimeSeriesDailyAdjustedQuery {
	query["outputsize"] = []string{"compact"}
	return query
}

func (query TimeSeriesDailyAdjustedQuery) OutputSizeFull() TimeSeriesDailyAdjustedQuery {
	query["outputsize"] = []string{"full"}
	return query
}

func (query TimeSeriesDailyAdjustedQuery) OutputSize(value string) TimeSeriesDailyAdjustedQuery {
	query["outputsize"] = []string{value}
	return query
}

func (query TimeSeriesDailyAdjustedQuery) DataTypeCSV() TimeSeriesDailyAdjustedQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesDailyAdjustedQuery) DataTypeJSON() TimeSeriesDailyAdjustedQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesDailyAdjustedQuery) DataType(value string) TimeSeriesDailyAdjustedQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesDailyAdjusted(ctx context.Context, q TimeSeriesDailyAdjustedQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesDailyAdjustedRow struct {
	TimeStamp        time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open             float64   `column-name:"open"`
	High             float64   `column-name:"high"`
	Low              float64   `column-name:"low"`
	Close            float64   `column-name:"close"`
	AdjustedClose    float64   `column-name:"adjusted_close"`
	Volume           int       `column-name:"volume"`
	DividendAmount   float64   `column-name:"dividend_amount"`
	SplitCoefficient float64   `column-name:"split_coefficient"`
}

func (client *Client) GetTimeSeriesDailyAdjustedCSVRows(ctx context.Context, q TimeSeriesDailyAdjustedQuery) ([]TimeSeriesDailyAdjustedRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesDailyAdjusted(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesDailyAdjustedRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesIntradayQuery url.Values

func QueryTimeSeriesIntraday(apiKey, symbol, interval string) TimeSeriesIntradayQuery {
	return TimeSeriesIntradayQuery{"function": []string{"TIME_SERIES_INTRADAY"}, "symbol": []string{symbol}, "interval": []string{interval}, "apikey": []string{apiKey}}
}

func (query TimeSeriesIntradayQuery) Adjusted(value bool) TimeSeriesIntradayQuery {
	query["adjusted"] = []string{strconv.FormatBool(value)}
	return query
}

func (query TimeSeriesIntradayQuery) ExtendedHours(value bool) TimeSeriesIntradayQuery {
	query["extended_hours"] = []string{strconv.FormatBool(value)}
	return query
}

func (query TimeSeriesIntradayQuery) Month(value time.Time) TimeSeriesIntradayQuery {
	query["month"] = []string{value.Format("2006-01")}
	return query
}

func (query TimeSeriesIntradayQuery) OutputSizeCompact() TimeSeriesIntradayQuery {
	query["outputsize"] = []string{"compact"}
	return query
}

func (query TimeSeriesIntradayQuery) OutputSizeFull() TimeSeriesIntradayQuery {
	query["outputsize"] = []string{"full"}
	return query
}

func (query TimeSeriesIntradayQuery) OutputSize(value string) TimeSeriesIntradayQuery {
	query["outputsize"] = []string{value}
	return query
}

func (query TimeSeriesIntradayQuery) DataTypeCSV() TimeSeriesIntradayQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesIntradayQuery) DataTypeJSON() TimeSeriesIntradayQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesIntradayQuery) DataType(value string) TimeSeriesIntradayQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesIntraday(ctx context.Context, q TimeSeriesIntradayQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesIntradayRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02 15:04:05"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    int       `column-name:"volume"`
}

func (client *Client) GetTimeSeriesIntradayCSVRows(ctx context.Context, q TimeSeriesIntradayQuery) ([]TimeSeriesIntradayRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesIntraday(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesIntradayRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesMonthlyQuery url.Values

func QueryTimeSeriesMonthly(apiKey, symbol string) TimeSeriesMonthlyQuery {
	return TimeSeriesMonthlyQuery{"function": []string{"TIME_SERIES_MONTHLY"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query TimeSeriesMonthlyQuery) DataTypeCSV() TimeSeriesMonthlyQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesMonthlyQuery) DataTypeJSON() TimeSeriesMonthlyQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesMonthlyQuery) DataType(value string) TimeSeriesMonthlyQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesMonthly(ctx context.Context, q TimeSeriesMonthlyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesMonthlyRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    int       `column-name:"volume"`
}

func (client *Client) GetTimeSeriesMonthlyCSVRows(ctx context.Context, q TimeSeriesMonthlyQuery) ([]TimeSeriesMonthlyRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesMonthly(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesMonthlyRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesMonthlyAdjustedQuery url.Values

func QueryTimeSeriesMonthlyAdjusted(apiKey, symbol string) TimeSeriesMonthlyAdjustedQuery {
	return TimeSeriesMonthlyAdjustedQuery{"function": []string{"TIME_SERIES_MONTHLY_ADJUSTED"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query TimeSeriesMonthlyAdjustedQuery) DataTypeCSV() TimeSeriesMonthlyAdjustedQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesMonthlyAdjustedQuery) DataTypeJSON() TimeSeriesMonthlyAdjustedQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesMonthlyAdjustedQuery) DataType(value string) TimeSeriesMonthlyAdjustedQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesMonthlyAdjusted(ctx context.Context, q TimeSeriesMonthlyAdjustedQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesMonthlyAdjustedRow struct {
	TimeStamp      time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open           float64   `column-name:"open"`
	High           float64   `column-name:"high"`
	Low            float64   `column-name:"low"`
	Close          float64   `column-name:"close"`
	AdjustedClose  float64   `column-name:"adjusted close"`
	Volume         int       `column-name:"volume"`
	DividendAmount float64   `column-name:"dividend amount"`
}

func (client *Client) GetTimeSeriesMonthlyAdjustedCSVRows(ctx context.Context, q TimeSeriesMonthlyAdjustedQuery) ([]TimeSeriesMonthlyAdjustedRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesMonthlyAdjusted(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesMonthlyAdjustedRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesWeeklyQuery url.Values

func QueryTimeSeriesWeekly(apiKey, symbol string) TimeSeriesWeeklyQuery {
	return TimeSeriesWeeklyQuery{"function": []string{"TIME_SERIES_WEEKLY"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query TimeSeriesWeeklyQuery) DataTypeCSV() TimeSeriesWeeklyQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesWeeklyQuery) DataTypeJSON() TimeSeriesWeeklyQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesWeeklyQuery) DataType(value string) TimeSeriesWeeklyQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesWeekly(ctx context.Context, q TimeSeriesWeeklyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesWeeklyRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    int       `column-name:"volume"`
}

func (client *Client) GetTimeSeriesWeeklyCSVRows(ctx context.Context, q TimeSeriesWeeklyQuery) ([]TimeSeriesWeeklyRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesWeekly(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesWeeklyRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type TimeSeriesWeeklyAdjustedQuery url.Values

func QueryTimeSeriesWeeklyAdjusted(apiKey, symbol string) TimeSeriesWeeklyAdjustedQuery {
	return TimeSeriesWeeklyAdjustedQuery{"function": []string{"TIME_SERIES_WEEKLY_ADJUSTED"}, "symbol": []string{symbol}, "apikey": []string{apiKey}}
}

func (query TimeSeriesWeeklyAdjustedQuery) DataTypeCSV() TimeSeriesWeeklyAdjustedQuery {
	query["datatype"] = []string{"csv"}
	return query
}

func (query TimeSeriesWeeklyAdjustedQuery) DataTypeJSON() TimeSeriesWeeklyAdjustedQuery {
	query["datatype"] = []string{"json"}
	return query
}

func (query TimeSeriesWeeklyAdjustedQuery) DataType(value string) TimeSeriesWeeklyAdjustedQuery {
	query["datatype"] = []string{value}
	return query
}

func (client *Client) GetTimeSeriesWeeklyAdjusted(ctx context.Context, q TimeSeriesWeeklyAdjustedQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type TimeSeriesWeeklyAdjustedRow struct {
	TimeStamp      time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open           float64   `column-name:"open"`
	High           float64   `column-name:"high"`
	Low            float64   `column-name:"low"`
	Close          float64   `column-name:"close"`
	AdjustedClose  float64   `column-name:"adjusted close"`
	Volume         int       `column-name:"volume"`
	DividendAmount float64   `column-name:"dividend amount"`
}

func (client *Client) GetTimeSeriesWeeklyAdjustedCSVRows(ctx context.Context, q TimeSeriesWeeklyAdjustedQuery) ([]TimeSeriesWeeklyAdjustedRow, error) {
	q.DataTypeCSV()
	res, err := client.GetTimeSeriesWeeklyAdjusted(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []TimeSeriesWeeklyAdjustedRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}
