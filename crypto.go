// Code generated by av-generate; DO NOT EDIT.

package alphavantage

import (
	"context"
	"net/http"
	"net/url"
	"time"
)

type CryptoIntradayQuery url.Values

func QueryCryptoIntraday(apiKey, symbol, market, interval string) CryptoIntradayQuery {
	return CryptoIntradayQuery{"function": []string{"CRYPTO_INTRADAY"}, "symbol": []string{symbol}, "market": []string{market}, "interval": []string{interval}, "apikey": []string{apiKey}}
}
func (query CryptoIntradayQuery) OutputSizeCompact() CryptoIntradayQuery {
	query["outputsize"] = []string{"compact"}
	return query
}
func (query CryptoIntradayQuery) OutputSizeFull() CryptoIntradayQuery {
	query["outputsize"] = []string{"full"}
	return query
}
func (query CryptoIntradayQuery) OutputSize(value string) CryptoIntradayQuery {
	query["outputsize"] = []string{value}
	return query
}
func (query CryptoIntradayQuery) DataTypeCSV() CryptoIntradayQuery {
	query["datatype"] = []string{"csv"}
	return query
}
func (query CryptoIntradayQuery) DataTypeJSON() CryptoIntradayQuery {
	query["datatype"] = []string{"json"}
	return query
}
func (query CryptoIntradayQuery) DataType(value string) CryptoIntradayQuery {
	query["datatype"] = []string{value}
	return query
}
func (client *Client) GetCryptoIntraday(ctx context.Context, q CryptoIntradayQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type CryptoIntradayRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02 15:04:05"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    float64   `column-name:"volume"`
}

func (client *Client) GetCryptoIntradayCSVRows(ctx context.Context, q CryptoIntradayQuery) ([]CryptoIntradayRow, error) {
	q.DataTypeCSV()
	res, err := client.GetCryptoIntraday(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []CryptoIntradayRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type DigitalCurrencyDailyQuery url.Values

func QueryDigitalCurrencyDaily(apiKey, symbol, market string) DigitalCurrencyDailyQuery {
	return DigitalCurrencyDailyQuery{"function": []string{"DIGITAL_CURRENCY_DAILY"}, "symbol": []string{symbol}, "market": []string{market}, "apikey": []string{apiKey}}
}
func (client *Client) GetDigitalCurrencyDaily(ctx context.Context, q DigitalCurrencyDailyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type DigitalCurrencyDailyRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    float64   `column-name:"volume"`
}

func (client *Client) GetDigitalCurrencyDailyCSVRows(ctx context.Context, q DigitalCurrencyDailyQuery) ([]DigitalCurrencyDailyRow, error) {
	res, err := client.GetDigitalCurrencyDaily(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []DigitalCurrencyDailyRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type DigitalCurrencyMonthlyQuery url.Values

func QueryDigitalCurrencyMonthly(apiKey, symbol, market string) DigitalCurrencyMonthlyQuery {
	return DigitalCurrencyMonthlyQuery{"function": []string{"DIGITAL_CURRENCY_MONTHLY"}, "symbol": []string{symbol}, "market": []string{market}, "apikey": []string{apiKey}}
}
func (client *Client) GetDigitalCurrencyMonthly(ctx context.Context, q DigitalCurrencyMonthlyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type DigitalCurrencyMonthlyRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    float64   `column-name:"volume"`
}

func (client *Client) GetDigitalCurrencyMonthlyCSVRows(ctx context.Context, q DigitalCurrencyMonthlyQuery) ([]DigitalCurrencyMonthlyRow, error) {
	res, err := client.GetDigitalCurrencyMonthly(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []DigitalCurrencyMonthlyRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type DigitalCurrencyWeeklyQuery url.Values

func QueryDigitalCurrencyWeekly(apiKey, symbol, market string) DigitalCurrencyWeeklyQuery {
	return DigitalCurrencyWeeklyQuery{"function": []string{"DIGITAL_CURRENCY_WEEKLY"}, "symbol": []string{symbol}, "market": []string{market}, "apikey": []string{apiKey}}
}
func (client *Client) GetDigitalCurrencyWeekly(ctx context.Context, q DigitalCurrencyWeeklyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type DigitalCurrencyWeeklyRow struct {
	TimeStamp time.Time `column-name:"timestamp" time-layout:"2006-01-02"`
	Open      float64   `column-name:"open"`
	High      float64   `column-name:"high"`
	Low       float64   `column-name:"low"`
	Close     float64   `column-name:"close"`
	Volume    float64   `column-name:"volume"`
}

func (client *Client) GetDigitalCurrencyWeeklyCSVRows(ctx context.Context, q DigitalCurrencyWeeklyQuery) ([]DigitalCurrencyWeeklyRow, error) {
	res, err := client.GetDigitalCurrencyWeekly(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []DigitalCurrencyWeeklyRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}
