// Code generated by github.com/portfoliotree/alphavantage/cmd/generate; DO NOT EDIT.

package alphavantage

import (
	"context"
	"net/http"
	"net/url"
)

type CryptoIntradayQuery url.Values

func QueryCryptoIntraday(apiKey, symbol, market, interval string) CryptoIntradayQuery {
	return CryptoIntradayQuery{"function": []string{"CRYPTO_INTRADAY"}, "symbol": []string{symbol}, "market": []string{market}, "interval": []string{interval}, "apikey": []string{apiKey}}
}
func (query CryptoIntradayQuery) OutputSizeCompact() CryptoIntradayQuery {
	query["outputsize"] = []string{"compact"}
	return query
}
func (query CryptoIntradayQuery) OutputSizeFull() CryptoIntradayQuery {
	query["outputsize"] = []string{"full"}
	return query
}
func (query CryptoIntradayQuery) OutputSize(value string) CryptoIntradayQuery {
	query["outputsize"] = []string{value}
	return query
}
func (query CryptoIntradayQuery) DataTypeCSV() CryptoIntradayQuery {
	query["datatype"] = []string{"csv"}
	return query
}
func (query CryptoIntradayQuery) DataTypeJSON() CryptoIntradayQuery {
	query["datatype"] = []string{"json"}
	return query
}
func (query CryptoIntradayQuery) DataType(value string) CryptoIntradayQuery {
	query["datatype"] = []string{value}
	return query
}
func (client *Client) GetCryptoIntraday(ctx context.Context, q CryptoIntradayQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type CryptoIntradayRow struct {
	TimeStamp string `column-name:"timestamp"`
	Open      string `column-name:"open"`
	High      string `column-name:"high"`
	Low       string `column-name:"low"`
	Close     string `column-name:"close"`
	Volume    string `column-name:"volume"`
}

func (client *Client) GetCryptoIntradayCSVRows(ctx context.Context, q CryptoIntradayQuery) ([]CryptoIntradayRow, error) {
	q.DataTypeCSV()
	res, err := client.GetCryptoIntraday(ctx, q)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	var rows []CryptoIntradayRow
	err = ParseCSV(res.Body, &rows, nil)
	if err != nil {
		return nil, err
	}
	return rows, nil
}

type DigitalCurrencyDailyQuery url.Values

func QueryDigitalCurrencyDaily(apiKey, symbol, market string) DigitalCurrencyDailyQuery {
	return DigitalCurrencyDailyQuery{"function": []string{"DIGITAL_CURRENCY_DAILY"}, "symbol": []string{symbol}, "market": []string{market}, "apikey": []string{apiKey}}
}
func (client *Client) GetDigitalCurrencyDaily(ctx context.Context, q DigitalCurrencyDailyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type DigitalCurrencyMonthlyQuery url.Values

func QueryDigitalCurrencyMonthly(apiKey, symbol, market string) DigitalCurrencyMonthlyQuery {
	return DigitalCurrencyMonthlyQuery{"function": []string{"DIGITAL_CURRENCY_MONTHLY"}, "symbol": []string{symbol}, "market": []string{market}, "apikey": []string{apiKey}}
}
func (client *Client) GetDigitalCurrencyMonthly(ctx context.Context, q DigitalCurrencyMonthlyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

type DigitalCurrencyWeeklyQuery url.Values

func QueryDigitalCurrencyWeekly(apiKey, symbol, market string) DigitalCurrencyWeeklyQuery {
	return DigitalCurrencyWeeklyQuery{"function": []string{"DIGITAL_CURRENCY_WEEKLY"}, "symbol": []string{symbol}, "market": []string{market}, "apikey": []string{apiKey}}
}
func (client *Client) GetDigitalCurrencyWeekly(ctx context.Context, q DigitalCurrencyWeeklyQuery) (*http.Response, error) {
	req, err := client.newRequest(ctx, url.Values(q))
	if err != nil {
		return nil, err
	}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	return res, nil
}
